// src/components/dataStructure/BinaryTreeVisualizer.jsx
import React, { useEffect, useRef, useState } from "react";

/*
Props:
 - tree: root node (object with { value, left, right } or with ids)
 - nodesById: (optional) map id => { id, value, leftId, rightId }  (not required)
 - highlight: { type, id, message, path } (ids may be generated by this visualizer)
 - nodeSize, gapY optional
*/

export default function BinaryTreeVisualizer({
  tree = null,
  nodesById = {},
  highlight = null,
  nodeSize = 64,
  gapY = 120,
}) {
  const containerRef = useRef(null);
  const [layoutNodes, setLayoutNodes] = useState([]); // { id, value, depth, x, y, rawNode }
  const [containerWidth, setContainerWidth] = useState(1000);

  // WeakMap to assign stable ids to nodes (won't prevent GC)
  const nodeIdMapRef = useRef(new WeakMap());
  const nextIdRef = useRef(1);

  const getNodeVizId = (node) => {
    if (!node) return null;
    // Prefer existing id if present and unique-ish
    if (node.id !== undefined && node.id !== null) return String(node.id);
    const map = nodeIdMapRef.current;
    if (map.has(node)) return map.get(node);
    const id = `viz_${nextIdRef.current++}`;
    map.set(node, id);
    return id;
  };

  // Build inorder layout positions and depths; uses tree object structure
  useEffect(() => {
    const rect = containerRef.current?.getBoundingClientRect();
    if (rect) setContainerWidth(rect.width || 1000);

    // Reset id generator only when a completely different tree object reference is provided
    // (we keep WeakMap so stable ids persist across updates for same node objects)
    // If your tree implementation replaces nodes with brand new objects often, this still works.

    const nodesInOrder = [];
    // Track depth for each node object (we'll push { node, depth } in inorder)
    function inorder(node, depth = 0) {
      if (!node) return;
      inorder(node.left, depth + 1);
      nodesInOrder.push({ node, depth });
      inorder(node.right, depth + 1);
    }

    inorder(tree, 0);

    if (!nodesInOrder.length) {
      setLayoutNodes([]);
      return;
    }

    const total = nodesInOrder.length;
    const usableWidth = Math.max(containerWidth - 120, 300);

    const computed = nodesInOrder.map((entry, idx) => {
      const x = (idx / Math.max(total - 1, 1)) * usableWidth + 60;
      const y = entry.depth * gapY + 40;
      const id = getNodeVizId(entry.node);
      return { id, value: entry.node.value, depth: entry.depth, x, y, rawNode: entry.node };
    });

    setLayoutNodes(computed);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [tree, containerRef.current, containerWidth, nodeSize, gapY, highlight]);

  // Update container width on resize
  useEffect(() => {
    const onResize = () => {
      const rect = containerRef.current?.getBoundingClientRect();
      if (rect) setContainerWidth(rect.width || 1000);
      setLayoutNodes((s) => [...s]);
    };
    window.addEventListener("resize", onResize);
    onResize();
    return () => window.removeEventListener("resize", onResize);
  }, []);

  // helper
  const nodeById = (id) => layoutNodes.find((n) => n.id === id);

  // Build edges by traversing the original tree object, but mapping to viz ids/positions
  const edges = [];
  (function buildEdges(node) {
    if (!node) return;
    const fromId = getNodeVizId(node);
    const left = node.left;
    const right = node.right;
    if (left) {
      const toId = getNodeVizId(left);
      const p = nodeById(fromId);
      const c = nodeById(toId);
      if (p && c) edges.push({ from: p, to: c });
      buildEdges(left);
    }
    if (right) {
      const toId = getNodeVizId(right);
      const p = nodeById(fromId);
      const c = nodeById(toId);
      if (p && c) edges.push({ from: p, to: c });
      buildEdges(right);
    }
  })(tree);

  // Highlight/class logic — allow highlight IDs to be either original ids or generated viz ids.
  const getNodeClass = (nodeLayout) => {
    const t = highlight?.type;
    const hid = highlight?.id !== undefined && highlight?.id !== null ? String(highlight.id) : null;
    const path = (highlight?.path || []).map(String);
    const isActive = hid && (hid === nodeLayout.id || hid === String(nodeLayout.rawNode?.id) || hid === String(nodeLayout.value));
    const isInPath = path.includes(nodeLayout.id) || path.includes(String(nodeLayout.rawNode?.id)) || path.includes(String(nodeLayout.value));

    if (t === "insert" && isActive) return "bg-emerald-600 text-white ring-4 ring-emerald-400";
    if (t === "delete" && isActive) return "bg-rose-600 text-white ring-4 ring-rose-400";
    if ((t === "found" || t === "notfound") && isActive) return "bg-yellow-300 text-black ring-4 ring-yellow-400";
    if (t === "traverse" && isInPath) return "bg-violet-700 text-white ring-4 ring-violet-400";
    if (t === "compare" && isInPath) return "bg-sky-500 text-white ring-2 ring-sky-300";
    if (isInPath) return "bg-slate-700 text-white/90";
    return "bg-slate-800 text-white";
  };

  const Node = ({ n }) => {
    const cls = getNodeClass(n);
    const radius = nodeSize / 2;
    return (
      <div
        key={n.id}
        className={`${cls} flex items-center justify-center rounded-full shadow-md`}
        style={{
          position: "absolute",
          left: n.x - radius,
          top: n.y - radius,
          width: nodeSize,
          height: nodeSize,
          borderRadius: 9999,
          transition: "all 720ms ease",
        }}
      >
        <div className="text-sm font-semibold select-none">{String(n.value)}</div>
      </div>
    );
  };

  // Render edges as smooth paths
  const SvgEdges = () => {
    if (!layoutNodes.length) return null;
    const rect = containerRef.current?.getBoundingClientRect() || { width: containerWidth, height: Math.max(...layoutNodes.map((n) => n.y)) + nodeSize + 60 };
    const width = rect.width;
    const height = rect.height + 40;

    return (
      <svg className="absolute inset-0 pointer-events-none" width={width} height={height} xmlns="http://www.w3.org/2000/svg">
        <defs>
          <linearGradient id="edge-grad" x1="0" x2="1">
            <stop offset="0%" stopColor="#60a5fa" />
            <stop offset="100%" stopColor="#7c3aed" />
          </linearGradient>
        </defs>

        {edges.map((e, i) => {
          const x1 = e.from.x;
          const y1 = e.from.y + nodeSize * 0.45;
          const x2 = e.to.x;
          const y2 = e.to.y - nodeSize * 0.45;
          const midX = (x1 + x2) / 2;
          const controlY = Math.min(y1, y2) - 20;
          const d = `M ${x1} ${y1} Q ${midX} ${controlY} ${x2} ${y2}`;
          const pathVals = (highlight?.path || []).map(String);
          const fromIn = pathVals.includes(String(e.from.id)) || pathVals.includes(String(e.from.rawNode?.id)) || pathVals.includes(String(e.from.value));
          const toIn = pathVals.includes(String(e.to.id)) || pathVals.includes(String(e.to.rawNode?.id)) || pathVals.includes(String(e.to.value));
          return <path key={`${e.from.id}-${e.to.id}-${i}`} d={d} fill="none" stroke="url(#edge-grad)" strokeWidth={(fromIn && toIn) ? 3 : 2} strokeDasharray={(fromIn && toIn) ? "0" : "6 6"} style={{ transition: "all 720ms ease" }} />;
        })}
      </svg>
    );
  };

  const computeStats = () => {
    if (!tree) return { nodes: 0, height: 0, root: null };
    const q = [tree];
    let nodes = 0;
    while (q.length) {
      const n = q.shift();
      nodes++;
      if (n.left) q.push(n.left);
      if (n.right) q.push(n.right);
    }
    function height(n) {
      if (!n) return 0;
      return 1 + Math.max(height(n.left), height(n.right));
    }
    const rootId = tree ? (getNodeVizId(tree) || (tree.id ?? String(tree.value))) : null;
    return { nodes, height: height(tree), root: rootId };
  };

  const stats = computeStats();

  return (
    <div ref={containerRef} className="relative w-full bg-transparent p-4 rounded-lg" style={{ minHeight: 360 }}>
      <div className="flex items-center gap-3 text-xs text-slate-300 mb-3 flex-wrap">
        <div className="flex items-center gap-2"><span className="w-3 h-3 rounded-full bg-emerald-600" /> Insert</div>
        <div className="flex items-center gap-2"><span className="w-3 h-3 rounded-full bg-rose-600" /> Delete</div>
        <div className="flex items-center gap-2"><span className="w-3 h-3 rounded-full bg-yellow-300" /> Found</div>
        <div className="flex items-center gap-2"><span className="w-3 h-3 rounded-full bg-violet-700" /> Traverse</div>
        <div className="flex items-center gap-2"><span className="w-3 h-3 rounded-full bg-sky-500" /> Compare / Path</div>
      </div>

      <SvgEdges />

      {layoutNodes.map((n) => (
        <Node key={n.id} n={n} />
      ))}

      <div className="absolute left-4 bottom-2 text-sm text-slate-400">
        {highlight?.message ?? ""}
        <div className="text-xs mt-1">Nodes: {stats.nodes} • Height: {stats.height} • Root: {stats.root ?? "—"}</div>
      </div>
    </div>
  );
}
